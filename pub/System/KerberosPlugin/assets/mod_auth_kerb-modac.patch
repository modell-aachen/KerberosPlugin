--- a/src/mod_auth_kerb.c	2008-12-04 11:14:03.000000000 +0100
+++ b/src/mod_auth_kerb.c	2013-04-03 11:11:16.319646483 +0200
@@ -147,7 +147,7 @@
 #define PROXYREQ_PROXY STD_PROXY
 #endif
 
-/*************************************************************************** 
+/***************************************************************************
  Auth Configuration Structure
  ***************************************************************************/
 typedef struct {
@@ -157,6 +157,8 @@
 	const char *krb_service_name;
 	int krb_authoritative;
 	int krb_delegate_basic;
+	int krb_anonymous_login;
+	const char *krb_anonymous_user;
 #if 0
 	int krb_ssl_preauthentication;
 #endif
@@ -220,6 +222,12 @@
    command("KrbDelegateBasic", ap_set_flag_slot, krb_delegate_basic,
      FLAG, "Always offer Basic authentication regardless of KrbMethodK5Pass and pass on authentication to lower modules if Basic headers arrive."),
 
+   command("KrbAnonymousLogin", ap_set_flag_slot, krb_anonymous_login,
+     FLAG, "Set to 'on' to bypass the enforced negotiation mechanism."),
+
+   command("KrbAnonymousUser", ap_set_string_slot, krb_anonymous_user,
+     TAKE1, "Sets the remote user in case of an anoymous login attempt."),
+
 #if 0
    command("KrbEnableSSLPreauthentication", ap_set_flag_slot, krb_ssl_preauthentication,
      FLAG, "Don't do Kerberos authentication if the user is already authenticated using SSL and her client certificate."),
@@ -325,6 +333,8 @@
 	((kerb_auth_config *)rec)->krb_service_name = NULL;
 	((kerb_auth_config *)rec)->krb_authoritative = 1;
 	((kerb_auth_config *)rec)->krb_delegate_basic = 0;
+	((kerb_auth_config *)rec)->krb_anonymous_login = 0;
+	((kerb_auth_config *)rec)->krb_anonymous_user = NULL;
 #if 0
 	((kerb_auth_config *)rec)->krb_ssl_preauthentication = 0;
 #endif
@@ -1622,6 +1632,35 @@
    char *negotiate_ret_value = NULL;
    char keyname[1024];
 
+   if (conf->krb_anonymous_login) {
+      const char *text = "'KrbAnonymousLogin' is set. Ignoring flag '%s'.";
+
+#ifdef KRB5
+      if (conf->krb_method_k5pass) {
+         conf->krb_method_k5pass = 0;
+         log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, text, "KrbMethodK5Passwd" );
+      }
+      
+      if (!conf->krb_method_gssapi) {
+         log_rerror(APLOG_MARK, APLOG_ERR, 0, r, 
+            "Flag 'KrbMethodNegotiate' is set to 'off' while 'KrbAnonymousLogin' is set to 'on'. Declining all requests!");
+         return DECLINED;
+      }
+#endif
+
+      if (conf->krb_delegate_basic) {
+         conf->krb_delegate_basic = 0;
+         log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, text, "KrbDelegateBasic" );
+      }
+
+      if (!conf->krb_authoritative) {
+         conf->krb_authoritative = 1;
+         log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, text, "KrbAuthoritative" );
+      }
+
+      conf->krb_verify_kdc = 1;
+   }
+
    /* get the type specified in .htaccess */
    type = ap_auth_type(r);
 
@@ -1638,6 +1677,12 @@
    else
       return DECLINED;
 
+   if (conf->krb_anonymous_login && !use_krb5) {
+      log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+         "KerberosV4 is NOT supported while flag 'KrbAnonymousLogin' is set." );
+      return DECLINED;
+   }
+
 #if 0
    if (conf->krb_ssl_preauthentication) {
       const char *ssl_client_verify = ssl_var_lookup(r->pool, r->server,
@@ -1653,9 +1698,15 @@
 	                                    ? "Proxy-Authorization"
 					    : "Authorization");
    if (!auth_line) {
-      set_kerb_auth_headers(r, conf, use_krb4, use_krb5, 
-	                    (use_krb5) ? "\0" : NULL);
-      return HTTP_UNAUTHORIZED;
+      if (conf->krb_anonymous_login) {
+         MK_USER = conf->krb_anonymous_user;
+         MK_AUTH_TYPE = NULL;
+         return OK;
+      } else {
+         set_kerb_auth_headers(r, conf, use_krb4, use_krb5,
+	                       (use_krb5) ? "\0" : NULL);
+         return HTTP_UNAUTHORIZED;
+      }
    }
    auth_type = ap_getword_white(r->pool, (const char **)&auth_line);
 
